import torch
from torch import nn
import scipy.interpolate as interp
import numpy as np


class ContinuousConv(nn.Module):
    def __init__(self, kernel_size, in_channel, out_channel):
        super().__init__()
        self.kernel_size = kernel_size
        self.in_channel = in_channel
        self.out_channel = out_channel
        self.weight = nn.Parameter(torch.randn(out_channel, in_channel, kernel_size, kernel_size))

    def forward(self, centre_position, positions, feats, neighbor_indxs):
        '''
        input one point and its neighbors information, output new features for centre point
        :param centre_position: centre point
        :param neighbor_positions:
        :param neighbor_feats:  in the shape of (N_neighbors, in_channel)
        :return: a out_channel-dimension feature for centre point
        '''

        # every filter generates a feature map for all points by adding the results from in channel
        # out_channel-d features can be generated by concat results from those filters
        res = []
        for each_filter in self.weight:
            # each filter has two channels and should output one feature by adding results from the two channels
            out_feat = 0
            for each_inchannel in range(self.in_channel):
                # kernel interpolation
                x = [i for i in range(self.kernel_size)]
                y = [i for i in range(self.kernel_size)]
                interpolation_func = interp.interp2d(x, y, each_filter[each_inchannel].data)

                # continuous convolution by f_i * g(^(x_i - x)) without x itself
                # length = len(neighbor_indxs)
                summation = 0   # result from one channel of one kernel
                for i in neighbor_indxs:
                    position_diff = np.abs(positions[i] - centre_position)
                    summation += interpolation_func(position_diff[0], position_diff[1]) * feats[i][each_inchannel]
                out_feat += summation
            res.append(out_feat)
        return res
